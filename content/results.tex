\part{Implementation and Numerical Results}
\label{part:implementation_and_results}






\chapter{Computer Implementation}
\label{ch:computer_implementation}

A large part of the present thesis is spent on computer implementation of
all major components needed towards an examination of discrete complex images
within the \ac{FMM}.
This chapter shall give an impression of the faced difficulties as well as
on insights gained in this process.

All codes are written in the C++ programming language, a choice which is made
for the following reasons.

It turns out that a unified and concerted implementation of all the
required bits, \eg, basic data types, \acp{TLGF}, reliable numerical
integration routines, various spectral and spatial Green's functions,
\ac{DCIM}, \ac{FMM}, and so forth, leads to a rather large code base.
Therefore, an ecosystem is needed which is suitable to maintain such a
project.
This requirement is fulfilled for C++ as advanced build and versioning systems
are available.

The second crucial point is the requirement for an extensive unit test
framework.
This is found to be essential for the implementation of algorithms most of
which are rather involved.
In order to achieve successful interaction of all the pieces, each of the
individual bricks must be thoroughly tested for all possible situations.
This especially proves true in the implementation of \ac{GPOF} and
\ac{DCIM}, which are essentially estimation algorithms exhibiting some inherent
unreliability.
Through extensive testing, implementations of these methods have been developed
which may not fail in more than $\SI{0.1}{\percent}$ of
the considered some ten-thousand parametrized test cases.

The third major reason for the choice of a compiled language lies in the very
nature of \ac{PE} methods which play a central role in the computation
of highly accurate reference solutions.
These are essentially iterative procedures which call a multitude of
small internal functions many times.
Here, a compiled language plays out its strengths as compared to interpreted
programming languages as the cost for repeated function look-up can be avoided
by using inline functions.





\section{Numerical Integration of Sommerfeld Integrals}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            width = 0.7\textwidth,
            height = 0.4\textwidth,
            axis lines=middle,
            axis line style = {->,>=stealth},
            xmin = -1,
            xmax = 20,
            ymin = -3,
            ymax = 3,
            xtick = {0,6,10,...,18},
            xticklabels = {$0$, $a$, $\xi_0$, $\xi_1$, $\xi_2$},
            ymajorticks = false,
            xlabel = {$\real{k_\rho}$},
            x label style={anchor=west},
            y label style={anchor=south},
            ylabel = {$\imag{k_\rho}$},
            ]
            \addplot [very thick, domain=0:1,samples=50]({3*(1+cos(deg(pi*(1-x))))},{sin(deg(pi*(1-x)))}); 
            \addplot[very thick, domain=6:19] {0};
        \end{axis}
    \end{tikzpicture}
    \caption{Real axis integration path as used for numerical integration.
    The point $a$ is chosen such that the real part of all integrand
    singularities is smaller than $a$.
    The (possibly oscillatory) tail integral is then well-behaved.}
    \label{fig:sip_numerical_integration}
\end{figure}

For high-accuracy reference computation of Sommerfeld integrals numerical
integration along the \ac{SIP} is implemented.
The theoretical backgrounds of the used methods can be fund in two comprehensive 
review papers \cite{Michalski1998,Michalski2016a}.

The implemented procedure is fully automated and thoroughly tested for the
complete dyadic Green's functions as well as for the generic scalar Green's
functions as specified by \cref{def:generic_scalar_gf}.
The routine employs the specific scheme illustrated in
\cref{fig:sip_numerical_integration}.
The breakpoint $a$ is chosen such that it is $\num{1.2}$ times the real part
of the singularity with the largest real part.
This choice is found to render the integrand well-behaved for $k_\rho > a$.
The $\xi_i$ are the breakpoints of the \ac{PE} algorithm.

The finite integral over the detour path connecting the origin with the
breakpoint $a$ is integrated along a semi-elliptical path parametrized by
\begin{equation}
    \gamma \left(t\right)
    =
    \frac{a}{2}
    \left(1 + \cos \phi\right)
    +
    \im w \sin \phi
    \qquad
    \phi \left(t\right)
    =
    \pi \left(1 - t\right)
    \qquad
    0 \leq t \leq 1
    \, ,
\end{equation}
where it is empirically found that
\begin{equation}
    w = 
    \begin{cases}
        \frac{1}{\rho}  & \rho > 0 \\
        \frac{a}{2}     & \mathrm{else}
    \end{cases}
\end{equation}
is a good choice for the depth of the detour into the first quadrant of the 
complex $k_\rho$ plane.

The tail integral is evaluated by the \ac{PE} algorithms prescribed in detail
in a paper by \textcite{Michalski2016a}.
The sub-interval breakpoints $\xi_i$ in \cref{fig:sip_numerical_integration} 
are chosen to coincide with the zeros of the kernel-Bessel function of the
Sommerfeld to integrate.
This method is referred to as \enquote{modified Sidi partition}
\cite{Michalski2016a}.
In order for this partitioning scheme to be applicable, $a$ must be selected
to coincide with a zero of $\besselj{\nu}\left(k_\rho \rho\right)$.
The implemented root search algorithm uses tabulated values
\cite[p.~409]{Abramowitz2014} for the first $\num{20}$ zeros and resorts to
McMahon's \cite[p.~236]{Olver2010} expansion for larger zeros.

Both major \ac{PE} algorithms prescribed in the paper by
\textcite{Michalski2016a}, \ie, Levin-Sidi \ac{PE} with numerical remainder
estimates, and Mosig-Michalski \ac{PE} with analytical estimates
are implemented.
The one to be used by the automated procedure depends on weather the calling
parent routine provides the analytical parameters or not.
The meaning of those is explained in the paper \cite[eq.~(70)]{Michalski2016a}.
In practice, it is found, however, that the Levin-Sidi implantation can very 
well compete with the Mosig-Michalski version.

On a more detailed level it turns out, that a reliable computer implementation
of the discussed algorithms needs to treat various pitfalls explicitly.
For example in the Levin-Sidi \ac{PE} method none of the partial integrals is
allowed to be close to zero, as the algorithm divides by these results.
On the other side, some known analytical properties can be readily utilized,
\eg, the that $\besselj{\nu} \left(0\right)$ vanishes for all $\nu \neq 0$.






\section{Discrete Complex Image Method}

For the \ac{DCIM} four different versions have been implemented: the
long-known two-level algorithm \cite{Aksun1996} and the three different
three-level variants outlined in the paper by \cite{Alparslan2010}.
Though extensive testing, version 2 of the three-level algorithm is found to
be most suitable for the case of half-space Green's functions.

As internal function fitting algorithm different possible implementations
of the \ac{GPOF} method \cite{Hua1989,Sarkar1995} were tested, where the
version for noisy data and with automated order selection was found superior.
Regarding automated order selection also one own approach was pursued.
The idea is to replace the original ordinary least squares solver in the final
step of the \ac{GPOF} method by a sparse least squares solver to reduce the 
number of obtained complex image terms as much as possible.
For this purpose the SPGL1 solver \cite{vandenberg2008, spgl1site}, for which a
C++ implementation is readily available from an earlier project, was considered.
This approach, however, is not found to be superior to the standard way of
order selection based on the ratio of singular values.







\section{Fast Multipole Method}

\begin{figure}
	\centering
	\begin{tikzpicture}
		[scale = 0.7]
		
		\newcommand{\w}{3}
		\newcommand{\dotsize}{1.5pt}
		
		\coordinate(r_s) at (1.5*\w,0.5*\w);
		\coordinate(r_o) at ($(r_s) + (2*\w,\w)$);
		\coordinate(r_prime) at ($(r_s) + (0.2*\w,0.45*\w)$);
		\coordinate(r) at ($(r_o) + (-0.3*\w,0.3*\w)$);
		
		% Ground
		\fill[color = blue!30!white] (-0.5*\w,0) rectangle (4.5*\w,-1.5*\w);
		
		% Coordinate system
		\draw [color=gray!20]  [step=\w] (-0.5*\w,-1.5*\w) grid (4.5*\w,2.5*\w);
		\draw[->,>=stealth] (-0.75*\w,0) -- (4.75*\w,0) node[right] {$\left(x,y\right)$};
		\draw[->,>=stealth] (0,-1.75*\w) -- (0,2.75*\w) node[above] {$\left(z\right)$};
		\foreach \c in {1,2,3,4}{\draw (\c*\w,-.1) -- (\c*\w,.1) node[below=4pt] {$\c w$};}
		\foreach \c in {1,2}{\draw (-0.1,\c*\w) -- (0.1,\c*\w) node[left=4pt] {$\c w$};}
		\draw (-0.1,-0.1) node[below left] {$0$};
		
		% Vectors
		\draw[->, >=stealth] (r_s) -- node[below right]{$\fmmDiffGroupCenters$} (r_o);
		\draw[->, >=stealth, line width=1.0pt, red] (r_prime) -- node[above left]{$\rdiff$} (r);
		\draw[->, >=stealth] (r_prime) -- (r_s);
		\draw[->, >=stealth] (r_o) -- (r);
		
		% Points
		\fill (r) circle (\dotsize) node[above]{$\robs$};
		\fill (r_prime) circle (\dotsize) node[above]{$\rsrc$};
		\fill (r_s) circle (\dotsize) node[below]{$\fmmSrcGroupCenter$};
		\fill (r_o) circle (\dotsize) node[below right]{$\fmmObsGroupCenter$};
		
		% Group boxes
		\draw($(r_s) - (\w/2,\w/2)$) rectangle ($(r_s) + (\w/2,\w/2)$);
		\draw($(r_o) - (\w/2,\w/2)$) rectangle ($(r_o) + (\w/2,\w/2)$);
		
	\end{tikzpicture}

	\caption[\acs{FMM} geometry]
	{Geometric definition of the \ac{FMM} implementation.}
	\label{fig:fmm_geometry}
\end{figure}

The implementation of a \ac{FMM} test code is based on the geometry shown in 
\cref{fig:fmm_geometry}.
All groups are cubes with side length $w$.
Towards an inclusion of a ground half-space at $z < 0$ the whole grouping
configuration is aligned with $z = 0$ as shown.
This notation is in accordance to the popular prescription of the \ac{FMM}
algorithm by \textcite{Coifman1993}.

Within the scope of the present thesis the goal is not to develop a
fully-featured \ac{FMM} implementation, \eg, for the use in an electromagnetic
solver.
It is rather desired to have a simple but flexible test code to examine
different possibilities to adapt the \ac{FMM} to the half-space Green's
function.
With this goal in mind an experimental version of the \ac{FMM}
is implemented which is restricted in the following aspects.
\begin{itemize}
	\item Only the scalar case is considered.
	\item Only $\diracDelta$-functions are used as basis and testing functions.
	\item The locations of basis and testing functions are set arbitrarily or 
	according to a specific test case. No real body-like structures are
	considered.
	\item Near interactions are not considered as their conventional \ac{MoM}
	treatment is straightforward.
\end{itemize}

Even though the described setup is conceptually similar to the examples
provided in a paper by \textcite{Hansen2013}, it is found that the subject
of this thesis requires a more versatile approach.
Therefore, the above specifications are merged into the prescription of the
algorithm given by the popular paper by \textcite{Coifman1993}.

Throughout this thesis the regular grouping scheme elucidated by
\cref{fig:fmm_geometry} is assumed for all considerations regarding the \ac{FMM}.
All groups are cubical with side length $w$ and uniquely identified by a
multiindex $\fmmMultiIndex \in \Z^3$ defined as
\begin{equation}
	\fmmMultiIndex \left(\pvec{r}\right) \coloneqq \lfloor \pvec{r} / w \rfloor
\end{equation}
where the floor function is defined to operate component-wise on the vector
$\pvec{r}$ given in Cartesian coordinates.

Within each group the source or observation points belonging to this group
are consecutively numbered by an index $\alpha \in \N$.
Globally, all points are identified by a unique index $n \in \N$.
The small example given in \cref{tab:fmm_grouping} illustrates
the chosen indexing scheme.

The implemented version of the \ac{FMM} does impose no restrictions to the
locations of basis and testing functions other than the fulfillment of the
separation criterion which makes the \ac{FMM} applicable.
The basis and testing functions are especially not assumed to be arranged
according to Galerkin's method \cite[p.~7]{Harrington1993}, where the
self-coupling case regularly occurs.

Due to this freedom it turns out to be advantageous to establish two separate
correspondences as the one given by \cref{tab:fmm_grouping}: one for source
points and one for observation points.

\begin{table}[]
	\centering
	\begin{tabular}{ccc}
		\toprule%
		$\fmmMultiIndex$ & $\alpha$ & $n$ \\
		\midrule
		$\left(0, 0, 0\right)$ & $1$ & $1$ \\
		                       & $2$ & $2$ \\
		                       & $3$ & $3$ \\
		\midrule
		$\left(5, 0, 2\right)$ & $1$ & $4$ \\
		                       & $2$ & $5$ \\
		                       & $3$ & $6$ \\
		                       & $4$ & $7$ \\
		\midrule
		$\left(0, 3, 0\right)$ & $1$ & $8$ \\
		                       & $2$ & $9$ \\
		                       & $3$ & $10$ \\
		\bottomrule
	\end{tabular}

	\caption[\acs{FMM} grouping scheme]
	{\acs{FMM} grouping scheme. The setup in this example has three groups
	containing three, four, and another three points, respectively.}
	\label{tab:fmm_grouping}
\end{table}











\chapter{Numerical Results}
\label{ch:numerical_results}

In this chapter a couple of example numerical results are presented which
prove the successful numerical implementation of the several components
announces in \cref{sec:scope_of_this_thesis}.
All results are computed using \texttt{double} precision floating point numbers.
The relative error measure used in most of the results is specified by
\begin{definition}[Relative error]
    Let $x_\mathrm{r} \neq 0$ be a reference value.
    Then the \emph{relative error} of a result $x_\mathrm{n}$ with respect to
    $x_\mathrm{r}$ is defined by 
    \begin{equation}
        \epsilon \left( x_\mathrm{n} \right) \coloneqq
        20 \log_{10} \abs{\frac{x_\mathrm{n} - x_\mathrm{r}}{x_\mathrm{r}}}
        \SI{}{\decibel}\, .
    \end{equation}
\end{definition}

Out of the infinite set of possible test cases, the two given by
\cref{tab:numerical_examples_half_spaces} are considered as they
represent physically meaningful cases of practical relevance.
Note that these two specific cases are also considered in a comprehensive
review paper by \textcite{Michalski2016b}.
Therefore, the numerical results can also be cross-checked against another
implementation which can be assumed to be solid.
\begin{table}[hbt]
	\centering
	\begin{tabular}{ccc}
		\toprule%
		Name & $\epsr^\prime$ & $\sigma$ \\
		\midrule
		Dry ground & $\num{3}$  & $\SI{0.1}{\milli\siemens\per\metre}$ \\
		Seawater   & $\num{81}$ & $\SI{4.0}{\siemens\per\metre}$ \\
		\bottomrule
	\end{tabular}
	\caption[Example half-space environments]
	{Example half-space environments used for numerical examples.
    Both environments are considered at $f = \SI{10}{\mega\hertz}$.}
	\label{tab:numerical_examples_half_spaces}
\end{table}

As the Sommerfeld identity is the most central result within the study of
multilayered media Green's functions, it makes sense to demand from a numerical
integration algorithm that it should be able to evaluate this integral very
accurately.
Furthermore, the Sommerfeld identity is in fact the only case where an
analytical reference solution is available in terms of a closed-form formula.
Figure \cref{fig:somm_id_ref_time:sub1} shows the respective results for a large
range of observation locations.
The upper bound of the relative error or $\SI{-134.42}{\decibel}$ indeed
proves the sanity of the implantation.
\cref{fig:somm_id_ref_time:sub2}, however, reveals that the performance
deteriorates for large $\rho$, which is the well-known issue of any
\ac{SIP}-based numerical integration algorithm.
The reasons for this are already discussed in \cref{ch:introduction}.

\begin{figure}
    \centering
    \begin{subfigure}[]{0.47\textwidth}
        \begin{tikzpicture}
            \pgfplotsset{small}
            \begin{axis}[
                width=\textwidth,% subfigure textwidth
                colormap/jet,
                colorbar horizontal,
                colorbar style = {xlabel = {Relative error in $\SI{}{\decibel}$}},
                unbounded coords = jump,
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                xmode = log,
                ymode = log,
                view = {0}{90},
                ]
                \addplot3 [
                    surf,
                    mesh/ordering=y varies,
                    ] table[
                        x = x_by_lambda_0, y = z_by_lambda_0, z = rel_err_db,
                    ]
                    {thesis_somm_id_ref_time.dat};
            \end{axis}
        \end{tikzpicture}
        \label{fig:somm_id_ref_time:sub1}
        \caption{Relative error. The maximum error is $\SI{-134.42}{\decibel}$.
        At the missing points numerical integration is exact down to machine
        precision.}
    \end{subfigure}
    \begin{subfigure}[]{0.47\textwidth}
        \begin{tikzpicture}
            \pgfplotsset{small}
            \begin{axis}[
                width=\textwidth,% subfigure textwidth
                colormap/jet,
                unbounded coords = jump,
                colorbar horizontal,
                colorbar style = {
                    xlabel = {Relative execution time},
                    xticklabel = {$10^{\pgfmathprintnumber{\tick}}$},
                    },
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                xmode = log,
                ymode = log,
                view = {0}{90},
                ]
                \addplot3 [
                    surf,
                    mesh/ordering=y varies,
                    ] table [
                        x = x_by_lambda_0,
                        y = z_by_lambda_0,
                        z expr=log10(\thisrow{rel_time}),
                        ]
                        {thesis_somm_id_ref_time.dat};
            \end{axis}
        \end{tikzpicture}
        \label{fig:somm_id_ref_time:sub2}
        \caption{Execution time relative to the point with the fastest
        execution.
        A total of $\num{50}$ evaluations of the Sommerfeld integral are timed
        at each point $\left(\rho,z\right)$.}
    \end{subfigure}

    \caption[Numerical evaluation of the Sommerfeld identity]
    {Numerical evaluation of the Sommerfeld identity with the source at
    the origin for $10^{-1} \leq a / \lambda_0 \leq 10^{3}$ where
    $a \in \left\{ \rho, z \right\}$.}
    \label{fig:somm_id_ref_time}
\end{figure}




The nest example shown in \cref{fig:surface_E_z_of_rho_and_f_axial_transmission}
actually recreates two Figures from the paper by \textcite{Michalski2016b}
for the vertical component $E_z$ of a \ac{VED} field right at the interface
of a Sommerfeld half-space for the dry-ground case.
The curves for the field component both as a function of $\rho$ as well as of
$f$ exactly match the literature result and therefore need no further
discussion.

\begin{figure}
    \newcommand{\widthFactor}{0.47}
    \newcommand{\heightFactor}{0.35}
    \centering
    \begin{tikzpicture}
        \pgfplotsset{small}
        \matrix {
            \begin{loglogaxis}[
                width=\widthFactor\textwidth,
                height=\heightFactor\textwidth,
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$\abs{G^\mathrm{EJ}_{zz}}$},
                enlargelimits = false,
                grid = major,
                ]
                \addplot[color = blue] table [] {thesis_surface_E_z_of_rho.dat};
            \end{loglogaxis}
            &
            \begin{loglogaxis}[
                width=\widthFactor\textwidth,
                height=\heightFactor\textwidth,
                xlabel = {Frequency in $\si{\hertz}$},
                ylabel = {$\abs{G^\mathrm{EJ}_{zz}}$},
                enlargelimits = false,
                grid = major,
                ]
                \addplot[color = blue] table [] {thesis_surface_E_z_of_f.dat};
            \end{loglogaxis}
            \\
            };
        \end{tikzpicture}
        \caption[]{Vertical component $E_z = G^\mathrm{EJ}_{zz}$ of the surface
        ($\robs \cdot \uv{z} = 0$) field of a \ac{VED} at
        $\rsrc = \SI{1}{\metre} \times \uv{z}$ for the dry ground example
        half-space.
        (See also \textcite{Michalski2016b} for this example.)}
        \label{fig:surface_E_z_of_rho_and_f_axial_transmission}
\end{figure}
        % Here, these results are obtained as one component of the dyadic Green's
        % function $\dyadicGF{EJ}$. As the shown curves match the ones given in a
        % paper by \textcite{Michalski2016b} which uses a specialized Sommerfeld
        % integral for the surface field at the half-space interface the
        % implementation of $\dyadicGF{EJ}$ is verified (at least for this very
        % component).






\begin{figure}
    \newcommand{\sizeFactor}{0.47}
    \centering
    \begin{subfigure}[t]{\textwidth}
        \begin{tikzpicture}
            \pgfplotsset{small}
            \matrix {
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$20\log_{10}\abs{G_\mathrm{tot}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=-26, point meta min=-97,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_tm_full_log,
                ]
                {thesis_generic_sgf_dry_ground.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$\real{G_\mathrm{refl}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=0.00065, point meta min=-0.00066,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_tm_refl_re,
                ]
                {thesis_generic_sgf_dry_ground.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            \\
            };
        \end{tikzpicture}
        \caption{\ac{TM} case}
        \label{fig:thesis_generic_sgf_dry_ground_tm}
    \end{subfigure}

    \begin{subfigure}[t]{\textwidth}
        \begin{tikzpicture}
            \pgfplotsset{small}
            \matrix {
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$20\log_{10}\abs{G_\mathrm{tot}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=-26, point meta min=-97,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_te_full_log,
                ]
                {thesis_generic_sgf_dry_ground.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$\real{G_\mathrm{refl}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=0.00065, point meta min=-0.00066,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_te_refl_re,
                ]
                {thesis_generic_sgf_dry_ground.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            \\
            };
        \end{tikzpicture}
        \caption{\ac{TE} case}
        \label{fig:thesis_generic_sgf_dry_ground_te}
    \end{subfigure}

    \caption[Generic scalar Green's function for a source over dry ground]
    {Generic scalar Green's functions for a source at
    $\rsrc = \lambda_0 \uv{z}$ over dry ground.
    The left plots show the magnitude of the total field while on the right
    the real part of the extracted reflected contribution is shown.}
    \label{fig:thesis_generic_sgf_dry_ground}
\end{figure}







\begin{figure}
    \newcommand{\sizeFactor}{0.47}
    \centering
    \begin{subfigure}[t]{\textwidth}
        \begin{tikzpicture}
            \pgfplotsset{small}
            \matrix {
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$20\log_{10}\abs{G_\mathrm{tot}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=-26, point meta min=-97,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_tm_full_log,
                ]
                {thesis_generic_sgf_seawater.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$\real{G_\mathrm{refl}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=0.00065, point meta min=-0.00066,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_tm_refl_re,
                ]
                {thesis_generic_sgf_seawater.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            \\
            };
        \end{tikzpicture}
        \caption{\ac{TM} case}
        \label{fig:thesis_generic_sgf_seawater_tm}
    \end{subfigure}

    \begin{subfigure}[t]{\textwidth}
        \begin{tikzpicture}
            \pgfplotsset{small}
            \matrix {
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$20\log_{10}\abs{G_\mathrm{tot}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=-26, point meta min=-97,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_te_full_log,
                ]
                {thesis_generic_sgf_seawater.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                colorbar horizontal,
                unbounded coords = jump,
                colorbar style = {xlabel = {$\real{G_\mathrm{refl}}$}},
                xlabel = {$\rho / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
            ]
            \addplot3 [
                surf,
                point meta max=0.00065, point meta min=-0.00066,
                mesh/ordering=y varies,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = g_te_refl_re,
                ]
                {thesis_generic_sgf_seawater.dat};

                \draw[thick] (axis cs:0,0,0) -- (axis cs:10,0,0);
            \end{axis}
            \\
            };
        \end{tikzpicture}
        \caption{\ac{TE} case}
        \label{fig:thesis_generic_sgf_seawater_te}
    \end{subfigure}

    \caption[Generic scalar Green's function for a source over seawater]
    {Generic scalar Green's functions for a source at
    $\rsrc = \lambda_0 \uv{z}$ over seawater.
    The left plots show the magnitude of the total field while on the right
    the real part of the extracted reflected contribution is shown.}
    \label{fig:thesis_generic_sgf_seawater}
\end{figure}







\begin{figure}
    \newcommand{\sizeFactor}{0.33}
    \newcommand{\pointMetaMax}{0.310}
    \newcommand{\pointMetaMin}{-0.811}

    \centering
    \begin{tikzpicture}
        \pgfplotsset{small}
        \matrix (m) {
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{xx}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_xx,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{xy}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_xy,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{xz}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_xz,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            \\
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{yx}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_yx,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{yy}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_yy,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{yz}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_yz,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            \\
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{zx}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_zx,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{zy}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_zy,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            &
            \begin{axis}[
                width=\sizeFactor\textwidth,
                height=\sizeFactor\textwidth,
                colormap/jet,
                xlabel = {$x / \lambda_0$},
                ylabel = {$z / \lambda_0$},
                view = {0}{90},
                title = $\real{G^\mathrm{EJ}_{zz}}$,
            ]
            \addplot3 [
                surf,
                mesh/ordering=y varies,
                point meta max = \pointMetaMax, point meta min = \pointMetaMin,
                ] table[
                    x = x_by_lambda_0, y = z_by_lambda_0, z = G_EJ_zz,
                ]
                {thesis_dgf_hs.dat};
                \draw[thick] (axis cs:-5,0,0) -- (axis cs:5,0,0);
            \end{axis}
            \\
            };
            \begin{axis}[
                anchor = north west,
                at = {(m.south west)},
                hide axis,
                scale only axis,
                height=0pt,
                width=0pt,
                colormap/jet,
                colorbar horizontal,
                point meta max=\pointMetaMax,
                point meta min=\pointMetaMin,
                colorbar style={
                    width=\textwidth,
                    xtick={-0.8,-0.7,-0.6,-0.5,-0.4,-0.3,-0.2,-0.1,0,0.1,0.2,0.3},
                    xlabel = {Real part of components in $\si{\volt\per\metre}$},
                    }
                ]
                \addplot [draw=none] coordinates {(0,0)};
            \end{axis}
        \end{tikzpicture} 
        \caption[Dyadic Green's function $\dyad{G}^\mathrm{EJ}$ for a source at
        $\rsrc = \lambda_0 \uv{z}$ over dry ground]
        {Dyadic Green's function $\dyad{G}^\mathrm{EJ}$ in the
        $y = 0$ cut plane for a source at $\rsrc = \lambda_0 \uv{z}$ over dry
        ground.}
\end{figure}


\section{Discrete Complex Image Method}


\begin{figure}
    \newcommand{\heightFactor}{0.3}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            name=plot1,
            width = \textwidth,
            height = \heightFactor\textwidth,
            xlabel = {$t$},
            xtick = {0,0.1,0.2},
            ylabel = {Random signal $y\left(t\right)$},
            grid = major,
            enlargelimits = false,
            legend entries={$\real{y}$,$\real{y}$},
            ]
            \addplot [
                blue,
                ] table [
                    x = t,
                    y = y_true_re,
                    ] {thesis_gpof_synth_signal.dat};
            \addplot [
                red,
                ] table [
                    x = t,
                    y = y_true_im,
                    ] {thesis_gpof_synth_signal.dat};
            \addplot [draw=magenta, fill=magenta, fill opacity = 0.1] coordinates {(0.1,40) (0.2,40) (0.2,-40) (0.1,-40)};
        \end{axis}
        \begin{axis}[
            name=plot2,
            at={($(plot1.south)+(0,-0.1\textwidth)$)},
            width = \textwidth,
            height = \heightFactor\textwidth,
            anchor=north,
            xlabel = {$t$},
            xtick = {0,0.1,0.2},
            ylabel = {Relative error in $\si{\decibel}$},
            grid = both,
            enlargelimits = false,
            ]
            \addplot [
                blue,
                ] table [
                    x = t,
                    y = rel_err_db,
                    ] {thesis_gpof_synth_signal.dat};
            \addplot [draw=magenta, fill=magenta, fill opacity = 0.1] coordinates {(0.1,-70) (0.2,-70) (0.2,-300) (0.1,-300)};
        \end{axis}
    \end{tikzpicture}
    \caption[]
    {Reconstruction of a random exponential series signal with known model
    order $M = \num{10}$ from parameters obtained by the \ac{GPOF} method.
    The signal is sampled with $f_\mathrm{s} = 10 f_\mathrm{max}$ at
    $N = \num{100}$ points where only the signal for $0 \leq t \leq \num{0.1}$
    is fed into the algorithm.
    The extrapolated region is visualized by colored background.}
    \label{fig:thesis_gpof_synth_signal}
\end{figure}



\begin{figure}
    \centering
    \begin{subfigure}[t]{\textwidth}
        \centering
        \newcommand{\sizeFactor}{0.47}
        \begin{tikzpicture}
            \pgfplotsset{small}
            \matrix {
                \begin{axis}[
                    width=\sizeFactor\textwidth,
                    height=\sizeFactor\textwidth,
                    colormap/jet,
                    colorbar horizontal,
                    colorbar style = {xlabel = Relative error in $\si{\decibel}$},
                    unbounded coords = jump,
                    xlabel = {$\rho / \lambda_0$},
                    ylabel = {$z / \lambda_0$},
                    xmode = log,
                    view = {0}{90},
                    title = {TM case},
                ]
                \addplot3 [
                    surf,
                    mesh/ordering=y varies,
                    ] table[
                        x = rho_by_lambda_0, y = z_by_lambda_0, z = rel_err_db_tm,
                        ]
                        {thesis_dcim_error.dat};
                \end{axis}
                &
                \begin{axis}[
                    width=\sizeFactor\textwidth,
                    height=\sizeFactor\textwidth,
                    colormap/jet,
                    colorbar horizontal,
                    colorbar style = {xlabel = Relative error in $\si{\decibel}$},
                    unbounded coords = jump,
                    xlabel = {$\rho / \lambda_0$},
                    ylabel = {$z / \lambda_0$},
                    xmode = log,
                    view = {0}{90},
                    title = {TE case},
                ]
                \addplot3 [
                    surf,
                    mesh/ordering=y varies,
                    ] table[
                        x = rho_by_lambda_0, y = z_by_lambda_0, z = rel_err_db_te,
                        ]
                        {thesis_dcim_error.dat};
                \end{axis}
                \\
            };
        \end{tikzpicture}
        \caption{Accuracy. The upper bounds are $\SI{-33.21}{\decibel}$ and
        $\SI{-58.62}{\decibel}$ for the \ac{TM} and \ac{TE} case, respectively.}
    \end{subfigure}

    \begin{subfigure}[]{\textwidth}
        \centering
        \begin{tikzpicture}
            \pgfplotsset{small}
            \begin{axis}[
                width = \textwidth,
                height = 0.3\textwidth,
                xlabel = {$z / \lambda_0$},
                ylabel = {Number of images},
                grid = major,
                enlargelimits = false,
                legend entries = {TM case,TE case},
            ]
            \addplot[
                only marks,
                mark = o,
                color = blue,
                ]
                table [
                    x = z_by_lambda_0,
                    y = n_images_tm,
                ]
                {thesis_dcim_images.dat};
            \addplot[
                only marks,
                mark = asterisk,
                color = red,
            ]
            table [
                x = z_by_lambda_0,
                y = n_images_te,
                ]
                {thesis_dcim_images.dat};
            \end{axis}
        \end{tikzpicture}
        \caption{Number of complex images.}
    \end{subfigure}

    \caption{Accuracy and required complex images for \ac{DCIM} computation
    of generic scalar Green's functions over dry ground with the source at
    $\rsrc = \lambda_0 \uv{z}$.
    The \ac{DCIM} is $\num{17.93}$ times faster than \ac{PE} accelerated
    numerical integration along the \ac{SIP}.}
    \label{fig:dcim_dry_ground}
\end{figure}


\section{Fast Multipole Method}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \pgfplotsset{small}
        \begin{axis}[
            width=0.6\textwidth,
            colormap/jet,
            colorbar,
            colorbar style = {ylabel = {Relative error in $\si{\decibel}$}},
            xlabel = {$x / \lambda_0$},
            ylabel = {$y / \lambda_0$},
            xmode = log,
            ymode = log,
            view = {0}{90},
        ]
        \addplot3 [
            surf,
            mesh/ordering=y varies,
            ] table[
                x = x_by_lambda_0, y = y_by_lambda_0, z = rel_err_db,
                ]
                {thesis_fmm_standard_accuracy.dat};
        \end{axis}
    \end{tikzpicture}
    \caption[Accuracy of standard \ac{FMM} implementation with real sources]
    {Accuracy of standard \ac{FMM} implementation with real sources.
    The cubical boxes are of side length $w = \lambda_0$.
    A total $\num{3600}$ observation points are distributed in the Cartesian
    $z = 0$ plane.
    The total $\num{500}$ source points are contained within a single group 
    centered at $w/2 \left(\uv{x} + \uv{y} + \uv{z}\right) + 20 w\uv{z}$.}
    \label{fig:thesis_fmm_standard_accuracy}
\end{figure}

